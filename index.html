<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D FPS 게임</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
        }
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            color: white;
            font-size: 20px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: #00ff00;
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            border: 2px solid #00ff00;
        }
        #ammo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 5px;
            font-size: 24px;
            border: 2px solid #00ff00;
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            pointer-events: all;
            border: 3px solid #00ff00;
        }
        #instructions h2 {
            margin-bottom: 20px;
            color: #00ff00;
        }
        #instructions button {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 18px;
            background: #00ff00;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        #instructions button:hover {
            background: #00dd00;
        }
        .hidden {
            display: none !important;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            pointer-events: all;
            border: 3px solid #ff0000;
        }
        #gameOver h2 {
            color: #ff0000;
            margin-bottom: 20px;
            font-size: 36px;
        }
        #gameOver button {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 18px;
            background: #00ff00;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="crosshair"></div>
        <div id="stats">
            <div>체력: <span id="health">100</span></div>
            <div>점수: <span id="score">0</span></div>
            <div>적 처치: <span id="kills">0</span></div>
        </div>
        <div id="ammo">탄약: <span id="ammoCount">30</span> / ∞</div>
        <div id="instructions">
            <h2>3D FPS 게임</h2>
            <p><strong>WASD</strong> - 이동</p>
            <p><strong>마우스</strong> - 시점 조작</p>
            <p><strong>클릭</strong> - 발사</p>
            <p><strong>R</strong> - 재장전</p>
            <p><strong>Shift</strong> - 달리기</p>
            <p style="margin-top: 20px;">적을 처치하고 생존하세요!</p>
            <button id="startButton">게임 시작</button>
        </div>
        <div id="gameOver" class="hidden">
            <h2>게임 오버!</h2>
            <p style="font-size: 24px; margin: 20px 0;">최종 점수: <span id="finalScore">0</span></p>
            <p style="font-size: 20px;">적 처치: <span id="finalKills">0</span></p>
            <button id="restartButton">다시 시작</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 게임 변수
        let scene, camera, renderer;
        let player = {
            position: new THREE.Vector3(0, 1.6, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            direction: new THREE.Vector3(0, 0, 0),
            rotation: { x: 0, y: 0 },
            health: 100,
            score: 0,
            kills: 0
        };
        let enemies = [];
        let bullets = [];
        let keys = {};
        let mouseMovement = { x: 0, y: 0 };
        let isPointerLocked = false;
        let gameStarted = false;
        let gameOver = false;
        
        // 무기 설정
        let weapon = {
            ammo: 30,
            maxAmmo: 30,
            reloading: false,
            fireRate: 100,
            lastShot: 0
        };

        // 씬 초기화
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 0, 100);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(player.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 조명
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            // 바닥
            const floorGeometry = new THREE.PlaneGeometry(200, 200);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228b22,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // 장애물 생성
            createObstacles();

            // 이벤트 리스너
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('click', shoot);
            
            document.getElementById('startButton').addEventListener('click', startGame);
            document.getElementById('restartButton').addEventListener('click', restartGame);

            window.addEventListener('resize', onWindowResize);
        }

        function createObstacles() {
            const obstacleGeometry = new THREE.BoxGeometry(3, 3, 3);
            const obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });

            for (let i = 0; i < 15; i++) {
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacle.position.set(
                    Math.random() * 80 - 40,
                    1.5,
                    Math.random() * 80 - 40
                );
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                scene.add(obstacle);
            }
        }

        function startGame() {
            document.getElementById('instructions').classList.add('hidden');
            gameStarted = true;
            
            // 포인터 락
            renderer.domElement.requestPointerLock();
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('mousemove', onMouseMove);
            
            spawnEnemies();
            animate();
        }

        function restartGame() {
            // 게임 상태 초기화
            gameOver = false;
            player.health = 100;
            player.score = 0;
            player.kills = 0;
            player.position.set(0, 1.6, 0);
            weapon.ammo = 30;
            
            // 적과 총알 제거
            enemies.forEach(enemy => scene.remove(enemy.mesh));
            bullets.forEach(bullet => scene.remove(bullet.mesh));
            enemies = [];
            bullets = [];
            
            // UI 업데이트
            updateUI();
            document.getElementById('gameOver').classList.add('hidden');
            
            // 다시 시작
            spawnEnemies();
            renderer.domElement.requestPointerLock();
        }

        function spawnEnemies() {
            setInterval(() => {
                if (gameOver || !gameStarted) return;
                
                const enemyGeometry = new THREE.BoxGeometry(1, 2, 1);
                const enemyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial);
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 20;
                enemyMesh.position.set(
                    Math.cos(angle) * distance,
                    1,
                    Math.sin(angle) * distance
                );
                enemyMesh.castShadow = true;
                
                scene.add(enemyMesh);
                
                enemies.push({
                    mesh: enemyMesh,
                    health: 100,
                    speed: 0.02 + Math.random() * 0.01,
                    lastAttack: 0
                });
            }, 2000);
        }

        function onPointerLockChange() {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
        }

        function onMouseMove(event) {
            if (!isPointerLocked) return;

            const sensitivity = 0.002;
            player.rotation.y -= event.movementX * sensitivity;
            player.rotation.x -= event.movementY * sensitivity;
            player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.x));
        }

        function onKeyDown(event) {
            keys[event.key.toLowerCase()] = true;
            
            if (event.key.toLowerCase() === 'r') {
                reload();
            }
        }

        function onKeyUp(event) {
            keys[event.key.toLowerCase()] = false;
        }

        function shoot() {
            if (!isPointerLocked || gameOver || weapon.reloading) return;
            
            const now = Date.now();
            if (now - weapon.lastShot < weapon.fireRate) return;
            if (weapon.ammo <= 0) {
                reload();
                return;
            }

            weapon.lastShot = now;
            weapon.ammo--;
            updateUI();

            // 총알 생성
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bulletMesh = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            bulletMesh.position.copy(camera.position);
            scene.add(bulletMesh);

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);

            bullets.push({
                mesh: bulletMesh,
                velocity: direction.multiplyScalar(1.5),
                life: 100
            });
        }

        function reload() {
            if (weapon.reloading || weapon.ammo === weapon.maxAmmo) return;
            
            weapon.reloading = true;
            setTimeout(() => {
                weapon.ammo = weapon.maxAmmo;
                weapon.reloading = false;
                updateUI();
            }, 1500);
        }

        function updatePlayer() {
            const speed = keys['shift'] ? 0.15 : 0.1;
            const direction = new THREE.Vector3();

            if (keys['w']) direction.z -= 1;
            if (keys['s']) direction.z += 1;
            if (keys['a']) direction.x -= 1;
            if (keys['d']) direction.x += 1;

            if (direction.length() > 0) {
                direction.normalize();
                direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
                player.position.add(direction.multiplyScalar(speed));
            }

            camera.position.copy(player.position);
            camera.rotation.set(player.rotation.x, player.rotation.y, 0);
        }

        function updateEnemies() {
            enemies.forEach((enemy, index) => {
                const direction = new THREE.Vector3()
                    .subVectors(player.position, enemy.mesh.position)
                    .normalize();
                
                enemy.mesh.position.add(direction.multiplyScalar(enemy.speed));
                enemy.mesh.lookAt(player.position);

                // 플레이어 공격
                const distance = enemy.mesh.position.distanceTo(player.position);
                if (distance < 2) {
                    const now = Date.now();
                    if (now - enemy.lastAttack > 1000) {
                        player.health -= 10;
                        enemy.lastAttack = now;
                        updateUI();
                        
                        if (player.health <= 0) {
                            endGame();
                        }
                    }
                }
            });
        }

        function updateBullets() {
            bullets.forEach((bullet, bulletIndex) => {
                bullet.mesh.position.add(bullet.velocity);
                bullet.life--;

                // 적과의 충돌 확인
                enemies.forEach((enemy, enemyIndex) => {
                    const distance = bullet.mesh.position.distanceTo(enemy.mesh.position);
                    if (distance < 1) {
                        enemy.health -= 34;
                        scene.remove(bullet.mesh);
                        bullets.splice(bulletIndex, 1);

                        if (enemy.health <= 0) {
                            scene.remove(enemy.mesh);
                            enemies.splice(enemyIndex, 1);
                            player.score += 100;
                            player.kills++;
                            updateUI();
                        }
                    }
                });

                // 수명이 다한 총알 제거
                if (bullet.life <= 0) {
                    scene.remove(bullet.mesh);
                    bullets.splice(bulletIndex, 1);
                }
            });
        }

        function updateUI() {
            document.getElementById('health').textContent = Math.max(0, player.health);
            document.getElementById('score').textContent = player.score;
            document.getElementById('kills').textContent = player.kills;
            document.getElementById('ammoCount').textContent = weapon.reloading ? '재장전중...' : weapon.ammo;
        }

        function endGame() {
            gameOver = true;
            document.getElementById('finalScore').textContent = player.score;
            document.getElementById('finalKills').textContent = player.kills;
            document.getElementById('gameOver').classList.remove('hidden');
            document.exitPointerLock();
        }

        function animate() {
            if (gameOver) return;
            
            requestAnimationFrame(animate);

            if (gameStarted && isPointerLocked) {
                updatePlayer();
                updateEnemies();
                updateBullets();
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
